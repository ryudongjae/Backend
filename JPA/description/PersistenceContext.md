영속성
====
영속성 컨텍스트
-----
    1.영속성 컨텍스트는 '엔티티를 영구 저장하는 환경' 이라는 뜻이다.
    2.영속성 컨택스트는 논리적인 개념이고 눈에 보이지 않는다.
    3.엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.
    ex)EntityManager.persist(entity);

엔티티의 생명주기
---
![IMG_0093](https://user-images.githubusercontent.com/73993220/132699340-8a5024ec-a438-42dc-b0dd-37993c1edc02.jpg)


----
    1.비영속(new/transient) 
        - 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
        - 객체만 생성한 상태를 비영속 상태라고 한다.(JPA랑 관계가 아직 없음)

    2.영속(managed) 
        - 영속성 컨텍스트에 관리되는 상태   
        - em.persist(객체) : 객체를 엔티티 매니저에 저장해서 영속상태가 된다.

    3.준영속(detached) 
        - 영속성 컨텍스트에 저장되었다가 분리된 상태
        - 영속성 컨텍스트가 제공하는 기능을 사용 못함 
        - em.detach(객체): 특정 엔티티만 준영속 상태로 전환
        - em.clear() : 영속성 컨텍스트를 완전히 초기화 
        - em.close() : 영속성 컨택스트 종료 

    4.삭제(removed) 
        -삭제된 상태
        -em.remove(객체) : 객체를 삭제한 상태 


영속성 컨텍스트의 이점
----
    1.1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터 베이스가 아닌 
      애플리케이션 차원에서 제공
    
    2.같은 트랜잭션 내에서는 동일성을 보장한다.
    
    3.커밋하는 순간에 쿼리문을 전송하는 쓰기 지연을 지원한다.
    
    4.데이터를 변경할 때 새로운 데이터를 전송하면 쓰기지연 저장소에 저장한 후 
      새로운에 데이터를 스냅샷을 찍어 1차 캐시의 값과 비교한다.
      비교 후 동일하지 않다면 UPDATE 쿼리문을 전송하는 기능이 변경 감지이다.
      이 과정에서 플러시가 발생한다.

변경 감지(Dirty checking)
---
![IMG_8B2E75DA4CF8-1](https://user-images.githubusercontent.com/73993220/132699409-ee04c988-0957-44a8-bba5-1e56cb676b82.jpeg)

flush
---
- 영속성 컨텍스트의 변경 내용을 데이터 베이스에 반영 
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 
- 쓰기 지연 SQL 저장소의 쿼리를 데이터 베이스에 전송 
- 영속성 컨텍스트를 비우지 않음 
- 트랜잭션 작업단위가 중요 -> 커밋 직전에만 동기화하면 됨 
  - ex) em.flush() - 직접 호출
  - ex) 트랜잭션 커밋 - 플러시 자동 호출 
  - ex) JPQL 쿼리 실행 - 플러시 자동 호출  
  - FlushModeType.AUTO ->커밋이나 쿼리를 실행할 때 플러시 
  - FlushModeType.COMMIT -> 커밋할 때만 플러시 

----


 
