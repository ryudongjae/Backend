코어 (Core)
===
    CPU의 기본 계산 단위입니다.
### 메모리
    메모리는 컴퓨터에서 작업을 수행하기 위해 처리 대상이나 결과 등을 저장하기 위한 공간이다.
    프로그램을 실행하기 위한 정보들은 메모리에 저장되어 처리된다.

프로세스 (Process)
===

### 프로세스란
    프로세스란 실행 중인 프로그램을 의미하고 보조저장장치로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 단위를 말합니다.

### 프로세스의 메모리 구조

    프로세스는 기본적으로 실행 코드가 저장되는 text 영역, 전역 변수 등을 수록하는 data 영역, 프로세스 실행 중에 동적으로 할당되는 
    메모리인 heap 영역, 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 stack 영역으로 이루어져 있습니다.

### 운영체제에 프로세스 저장방식

    프로세스는 PCB라는 자료구조를 통해서 저장되어집니다. PCB란 Process Control Block의 줄임말으로 특정 프로세스에 대한 
    중요한 정보를 저장하고 있는 운영체제의 자료구조이고 이는 PID, Process Status, PC, CPU 레지스터, 
    CPU 스케줄링 정보 등으로 구성되어 집니다.

### 스레드 (Thread)
    스레드는 프로세스의 CPU 이용을 위한 기본 단위로 프로세스의 주소 공간이나 자원등을 공유해 프로세스를 여러 실행 흐름으로 실행시킬 수 있습니다.

### 멀티 스레딩

    하나의 프로세스를 다수의 실행 단위 즉, 여러개의 스레드로 구분하여 프로세스의 자원을 공유해 처리 능력을 향상 시키는 것을 
    멀티스레딩이라고 합니다.

### 스택을 스레드마다 독립적으로 할당하는 이유가 있나요?
    스택은 함수의 인자, 복귀 주소, 지역 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 
    독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이기 때문에 
    프로세스를 여러 실행 흐름으로 만들기 위해서는 스레드에 스택을 독립적으로 할당해야 합니다.

### PC Register를 스레드마다 독립적으로 할당하는 이유
    PC 값은 다음에 실행될 명령어의 주소를 나타내므로 프로세스의 개별 실행 흐름인 스레드가 독립적으로 명령어들을 실행하기 위해선 
    스레드에 PC 레지스터가 독립적으로 할당되어야 합니다.

## 멀티 스레드 (MultiThread)
    멀티스레드는 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것 

### 멀티 스레드의 장단점
* 장점 
  * 멀티 스레드를 통해 하나의 실행 흐름인 프로세스를 여러 개의 실행 흐름으로 만들 수 있습니다. 
  * 이를 통해 프로세스의 처리 능력 향상과 자원의 소모가 줄어드는 것을 기대할 수 있습니다. 
* 단점 
  * 하지만 여러 개의 스레드가 동일한 자원을 접근할 경우 경쟁 조건이 발생할 수 있으며 동기화를 신경 써줘야 합니다.
  * 스레드간의 동기화를 위한 동기화 기법들은 매우 다양하며 잘못 사용할 경우 병목 현상을 발생시킬 수 있어 이를 사용하기 위해 많은 자원이 필요하다는 것이 단점입니다.

### 멀티 스레드와 멀티 프로세스의 차이

    멀티 스레드와 멀티 프로세스의 차이는 여러 실행흐름을 프로세스를 통해서 만드느냐 아니면 프로세스 내의 스레드를 통해서 만드느냐의 차이입니다.
    이 두가지 기법 다 동시에 여러 작업을 수행한다는 점에서 목적은 같지만, 서로 장단점이 존재하기 때문에 개발 도메인에서 적합한지, 
    단점이 뭐가 있고, 장점은 뭐가 있는지, 왜 이 기법을 사용해야 하는지에 대해 팀 내에서 깊게 논의 한 후 시스템에 적용해야 한다고 생각합니다.

### 데드락(DeadLock)
    데드락 또는 교착상태란 한정된 자원을 여러 프로세스가 사용하고자 할 떄 발생하는 상황으로, 프로세스가 자원을 얻기 위해 영구적으로 기다리는 상태이다.

### 세마포어,뮤텍스 차이
    뮤텍스는 Locking 메커니즘으로 락을 걸은 스레드만이 임계 영역을 나갈때 학을 해제할 수 있습니다. 하지만 세마포어는 Signaling 메커니즘으로 락을 걸지 않은 스레드도
    signal을 사용해 학을 해제할 수 있다.세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용할 수 있다.

### CPU의 메모리 I/O 도중 생기는 병목 현상 솔루션
    메모리를 계층화하여 변복현상을 해결한다.자주 접근하는 데이터의 경우 캐시에 저장하여 접근 속도를 향상 시킴으로써 부하를 줄이고 있다.

### 프로세스 스케줄러란
    멀티 프로세스 기법을 사용하는 시스템은 프로세스의 실행 순서를 스케줄링 해야만 합니다.
    이러한 프로세스의 실행 순서를 스케줄링하는 도구를 프로세스 스케줄러라고 합니다.

### 프로세스 스케줄러 종류
    프로그램이 저장되어 있는 디스크에서 메모리로 프로세스 스케줄링을 담당하는 Job Schduler, 
    CPU와 메모리 사이의 스케줄링을 담당하는 CPU Schecudler, 메모리에서 디스크로 프로세스 스케줄링을 담당하는 Swapper등이 있는걸로 알고 있습빈다.

### CPU 스케줄러란
    Ready Queue에 있는 프로세스들을 스케줄링하는 스케줄러를 CPU 스케줄러라고 합니다.

### CPU 스케줄러의 기법에는 어떤게 있을까요?
    먼저 Ready Queue에 들어온 프로세스를 먼저 처리하는 First Come Fist Serve(FCFS) 스케줄링 기법,
    CPU Burst Time이 짧은 프로세스를 먼저 처리하는 Shortest Job First(SJF) 스케줄링 기법, 
    SJF 기법 기반으로 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어져 가장 짧은 프로세스를 먼저 처리하는 Shortest Remaining time First(SRT) 기법, 
    프로세스에 우선순위를 부여하여 우선순위가 높은 프로세스를 먼저 처리하는 Priority Schduling 기법, 
    프로세스에 CPU 할당 시간을 정해 놓아 CPU를 할당하는 방법인 Round Robin 기법 등이 있습니다.

### 동기와 비동기의 차이
    동기는 요청과 동시에 결과가 일어나는 경우를 동기라고 표현하고, 
    비동기는 요청과 결과가 동시에 일어나지 않는 경우를 비동기라고 표현한다.

### block과 non-block의 차이는 무엇인가요?
    요청에 대한 응답을 얻기 까지 다른 실행 흐름들이 기다리는 것을 blocking이라고 하고, 
    다른 실행 흐름이 요청에 대한 응답을 대기하지 않고 자유롭게 CPU나 메모리 등을 이용하는 상황을 non-blocking 이라고 한다.

### 켄텍스트 스위칭
    컨텍스트 스위칭은 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정이다.
    컨텍스트 스위칭은 현재 실행중인 프로세스의 상태를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구한다.

### 인터럽트 
    CPU가 프로세스를 싱행하고 있을 때 입출력 하드웨어 등의 장치나 예외 상황이 발생하여 처리가 필요함을 CPU에게 알이는 것이다.

프로세스 동기화 (Process Synchronization)
===

### Critical Section은 무엇인가요?

    동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역을 Critical Section 이라고 합니다.

### Critical Section Problem을 해결하기 위한 조건

    Critical Section Problem을 해결하기 위한 조건은 
    첫 번째 특정 프로세스가 Critical Section을 수행하고 있다면 다른 프로세스는 이 Critical Section에 들어오지 못하게 하는 상호 배제(Mutual Exclusion) 조건입니다.
    두 번째는 Critical Section에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Critical Section 진입 후보 프로세스로서 참여할 수 있다는 조건인 Progress 입니다.
    세 번째는 특정 프로세스가 Ciritcal Section에 진입 신청 후 받아들여지기까지 기간이 한정되어야 함을 나타내는 Bounded Waiting 입니다.

### Critical Section Problem을 해결하기 위한 기법

    첫 번째는 하드웨어 기반 해결책인 Lock입니다. Critical Section에 진입하기전에 Lock을 얻고, Critical Section에서 빠져 나올 때 Lock을 방출함으로써 프로세스간에 동기화를 유지합니다.
    두 번째는 Semaphores 입니다. 소프트웨어 상에서 Ciritcal Section 문제를 해결하기 위한 동기화 도구이며, 
    두 개의 프로세스 사이에서 동기화를 유지할 수 있는 이진 세마포와 프로세스 세개 이상의 프로세스 사이에서 동기화를 유지할 수 있는 카운팅 세마포가 있습니다.
    세 번째는 모니터 입니다. 모니터는 고급 언어의 설계 구조물로서, 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태 입니다.

메모리 관리 전략
===

### Swapping 이란 무엇인가요?
    Swapping 이란 메모리의 관리를 위해 사용되는 기법입니다. 
    CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억장치(하드디스크)로 내보내고 다른 프로세스를 메모리로 불러 들이는 것을 의미합니다.
    이러한 과정을 swap (스왑시킨다) 이라 한다. 
    주 기억장치(RAM)으로 불러오는 과정을 swap-in, 보조 기억장치로 내보내는 과정을 swap-out 이라 한다.
    swap 에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할 때 Swapping이 시작된다.

### Swapping을 하면서 발생하는 문제점
    대표적으로 단편화(Fragmentation) 문제를 들 수 있습니다. 
    프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 메모리 사이에 사용 하지 못할 만큼의 작은 자유 공간들이 늘어나게 되는데 
    이를 단편화라고 합니다.
    단편화의 종류는 크게 외부 단편화와 내부 단편화로 나눌 수 있습니다. 외부 단편화란 메모리에서 프로세스 사이 사이 남는 공간들을 의미하는 것이고, 
    내부 단편화란 프로세스가 사용하는 메모리 공간에서 남는 부분을 의미하는 것입니다.

### 외부 단편화를 해소하기 위한 방법

    압축이 있을 것 같습니다. 외부 단편화를 해소하기 위해 프로세스가 사용하는 메모리 공간들을 한쪽으로 몰아, 
    자유 공간을 확보하는 방법론 이지만, 작업효율이 좋지 않아 잘 사용하지 않습니다.

### 다른 외부 단편화 문제를 해결할 수 있는 방법
    대표적인 예로는 메모리 공간이 연속적이어야 한다는 제약을 없애는 페이징 기법을 들 수 있습니다. 
    물리 메모리를 Frame 이라는 고정 크기로 분리하고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리하는 기법입니다.
    이러한 페이징 기법을 통해 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있습니다.
    즉, 하나의 프로세스가 사용하는 공간을 여러개의 페이지로 나뉘어서 논리 메모리에서 관리하고,
    개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장하는 방법입니다.
    하지만 페이지의 크기는 정해져 있기 때문에 내부 단편화는 발생할 수 있다고 생각합니다.

### 세그멘테이션이란
    세그멘테이션은 프로세스를 물리적 크기의 단위가 아닌 논리적 내용의 단위인 세그먼트로 분할하고 메모리를 할당하며 주소를 변환하는 기법이다.
    세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법에서처럼 미리 분할해 둘 수 없고,
    메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법이다.
    세그먼트의 단위가 다르기 때문에 메모리에 서로 다른 크기를 가진 여러 세그먼트를 저장할 시 외부 단편화가 생기는 문제점이 존재해 잘 사용하지는 않습니다.

### 가상 메모리 (Virtual Memory)
    
    가상 메모리란 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이며, 
    프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

### 왜 가상 메모리가 나오게 되었는가?

    실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었다. 
    또한 멀티 프로세스상에서 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와, 페이지 교체등의 성능 이슈가 발생했기 때문에 이를 해결하기 위해 가상 메모리 기법이 나오게 되었습니다.

### 가상 메모리를 통해서 우리는 어떤 장점을 얻을 수 있는가?
    프로그램의 일부분만 메모리에 올릴 수 있게 되었고 이를 통해 물리 메모리 크기에 제약을 받지 않게 되었습니다. 
    고로 더 많은 프로그램을 동시에 실행할 수 있게 되었다. 또한 swap에 필요한 입출력이 줄었기 때문에 프로그램들이 빠르게 실행된다는 장점을 가지고 있다.

### 가상 메모리는 어떻게 동작하는가?
    가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다. 
    이로써 작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있습니다.
    가상 주소 공간이란 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다.
    프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로써 현재 직접적으로 필요치 않는 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.
    가상 메모리는 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 합니다.
    프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리를 통해 통신할 수 있다. 
    이 또한, 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.

### 요구 페이징 (Demand Paging)이란 무엇인가?
    프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신,
    초기에 필요한 것들만 적재하는 전략을 요구 페이징이라 하며 가상 메모리 시스템에서 많이 사용된다. 
    요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다.

### 페이지 교체 알고리즘이란
    요구 페이징에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에,
    프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault가 발생하게 되면, 
    원하는 페이지를 보조저장장치에서 가져오게 되는 것을 의미합니다.

페이지 교체 알고리즘의 순서
1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 빈 페이지 프레임을 찾는다.
3. 페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고른다.
4. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
5. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
6. 사용자 프로세스 재 시작

### 페이지 교체 알고리즘에는 어떠한 것들이 있는가?

* FIFO 페이지 교체 : 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다.
* 최적 페이지 교체 : 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 알고리즘이다.
* LRU (Least Recently Used) 페이지 교체 : 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다. (최적 알고리즘 근사 알고리즘)
* LFU (Least Frequently Used) 페이지 교체 : 참조 횟수가 가장 적은 페이지를 교체하는 방법이다.
* MFU (Most Frequently Used) 페이지 교체 : 참조 횟수가 가장 많은 페이지를 교체하는 방법이다.

---


캐시(Cache)
===

### 캐시 메모리란 무엇인가?
    캐시 메모리란 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다.

### 캐시 메모리에서 가장 신경써야 하는 문제
    캐시 메모리의 역할을 수행하기 위해서는 CPU가 어떤 데이터를 원할 것인가를 예측할 수 있어야 한다. 
    즉, 적중률(hit rate)을 극대화 시켜야 한다.

### 적중률(hit rate)을 극대화 시키기 위해 어떻게 해야 하는가?
    적중률을 극대화 시키기 위해 데이터 지역성(Locality)의 원리를 사용한다. 
    즉, Locality란 기억 장치 내의 정보를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성인 것이다.

### 지역성은 어떻게 나뉘는가?
    데이터 지역성은 대표적으로 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)으로 나뉘고 이는 다음과 같다.

* 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성.
* 공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성