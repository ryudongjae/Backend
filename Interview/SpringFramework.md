### Spring
* 스프링 프레임워크는 자바를 위한 오픈소스 애플리케이션 프레임워크로서 자바 기반 엔터프라이즈 애플리케이션 개발을 위해 다양한 서비스를 제공
--- 
### MVC 패턴이란?

MVC(Model-View-Controller)패턴은 아키텍쳐를 설계하기 위한 디자인 패턴입니다.
* MVC 패턴은 애플리케이션을 개발할 때 그 구성요소를 3가지로 나눕니다.
* Model: 데이터를 저장하는 컴포넌트
* View: 사용자 인터페이스(UI) 컴포넌트
* Controller: 사용자의 요청을 처리하고 Model과 View를 중개하는 컴포넌트

---
### ➡️spring MVC
spring MVC란 웹 애플리케이션 개발을 위한 MVC패턴 기반의 웹 프레임워크이다. Spring Mvc는 애플리케이션의 구성요소를
Model,View ,Controller 로 분리합니다. 또한 Spring MVC는 아래와 같은 컴포넌트들로 구성된다.
* Dispatcher Servlet : 클라이언트의 요청을 먼저 받아들이는 서블릿으로, 요청에 맞는 컨트롤러에게 요청을 전달함
* Handler Mapping : 해당 요청이 어떤 컨트롤러에게 온 요청인지 검사함
* Controller : 클라이언트의 요청을 받아 처리하여 결과를 디스패처 서블릿에게 전달함
* ViewResolver : View의 이름을 통해 알맞은 View를 찾음
* View : 사용자에게 보여질 UI 화면
---

### ➡️Spring MVC 작동 원리
1. 클라이언트는 URL을 통해 요청을 전송한다.
2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
3. 디스패처 서블릿은 핸들러 어댑터에게 요청을 전달한다.
4. 핸들러 어댑터는 해당 컨드롤러에 요청을 전달한다.
5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
6. 디스패처 서블릿은 뷰리졸버를 통해 반환할 뷰를 찾는다.
7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
8. 데이터가 추가된 뷰를 반환한다.
---

### ➡️Spring MVC의 장점과 단점
* 장점
  * 의존성 주입을 통해 컴포넌트 간의 결합도를 낮출 수 있어 단위 테스트가 용이하다.
  * 제어의 역전을 통해 빈(객체)의 라이프싸이클에 관여하지 않고 개발에 집중할 수 있다.
* 단점
  * XML을 기반으로 하는 프로젝트 설정은 너무 많은 시간을 필요로 한다.
  * 톰캣과 같은 WAS를 별도로 설치해주어야함
---
### Spring boot
* 자동설정을 도입하여 Dispatcher Servlet 등과 같은 설정 시간을 줄여준다.
* 프로젝트의 의존성을 독입적으로 선택하지 않고 spring-boot-starter로 모아두어 외부 도구들을 사용하기 편리하다.
* 내장 톰캣을 제공하여 별도의 WAS를 필요로 하지 않음
---

### @Bean, @Configuration, @Component
* 개발자가 직접제어가 불가능한 외부 라이브러리 또는 설정을 위한 클래스를 Bean으로 등록할 때 @Bean어노테이션을 활용
* 1개 이상의 @Bean을 제공하는 클래스의 경우 반드시 @Configuration을 명시해주어야 한다.
* 개발자가 직접 개발한 클래스를 Bean으로 등록하고자 하는 경우 @Component 어노테이션을 활용한다.
---
### Springboot 와 SpringFramework
* 스프링 부트와 스프링 프레임워크의 가장 큰 차이는 Auto Configuration 이다.
* 예를 들어 Spring Mvc프로젝트를 SpringFramework 기반으로 구성하면 컴포넌트 스캔,bean 설정, Dispatcher Servlet 설정, View Resolver JDBC 설정,웹 jar설정 등 다양한 설정을 해야하지만 이를 SpringBoot기반으로 구성함으로써 초기 개발 환경 세팅에 걸리는 리소스를 절약할 수 있다.
* 스프링 부트로 프로젝트를 생성할 시 스프링 부트에서는 내장 서블릿 컨테이너인 톰캣이 자동적으로 설정된다.
---
### Spring Singleton Pattern
* 싱글톤 패턴은 1개의 클래스당 1개의 객체만을 생성하여 사용하는 디자인 패턴이다. Spring에서는 스프링 컨테이너가 관리하는 객체인 Bean을 싱글톤 패턴으로 구현하여 제공한다.  
* Spring에서는 private 생성자나 static 메소드를 사용하지 않고도 해당 객체를 싱글톤으로 관리하여 객체지향적 개발을 할 수 있다.또한 자바의 싱글촌은 해당 클래스로더 내에서 
* 1개의 인스턴스만을 생성할 수 있지만, Spring에서는 스프링 컨테이너의 컨택스트에서 1개의인스턴스를 생성할 수 있다.  
* 그에 따라 자바의 싱글톤은 JVM에 라이프사이클의 제어가 되지만, Spring의 싱글톤은 스프링 컨텍스트에 의해 제어가 된다.  
* 또한 Spring에서의 싱글톤은 Thread safety를 자동으로 보장하는 반면 자바로 구현한 싱글톤 패턴은 반드시 보장하지 못한다.

### Spring 싱글톤 패턴 단점
* private 생성자를 갖고 있어 상속이 불가능하다. 
* 테스트하기 힘들다. 
* 서버 환경에서는 싱글톤이 1개만 생성됨을 보장하지 못한다. 
* 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.

  그래서 스프링은 컨테이너를 통해 직접 싱글톤 객체를 생성하고 관리하는데, 이를 통해 다음과 같은 장점을 얻을 수 있다.
* static 메소드나 private 생성자 등을 사용하지 않아 객체지향적 개발을 할 수 있다.
* 테스트를 하기 편리하다.


---
### Spring(DI,DL,Ioc,Aop)
* **DI(Dependency Injection)** 의존성 주입 : 한 객체에서 다른 객체를 필요로 하여 의존성을 갖게 하는 기술
* **DL(Dependency Look-up)** : 한 객체에서 필요로 하는 다른 객체를 찾아서 사용하는 기술
* **Ioc(Inversion of Control)** : 직접 제어해야하는 부분에 대한 권한을 프레임워크 들에 넘기는 기술
* **AOP(Aspect Oriented Programming)** : 공통의 관심사항을 추출하여 원하는 곳에 적용하는 기술
---
### Spring Bean 주입방법

  @Autowired 어노테이션으로 필드에 주입 받을 수도 있고, 생성자를 통해서 주입 받을수 있고, setter를 통해 주입 받을 수 있다.  
  Bean 주입 시 같은 이름 및 같은 타입의 빈이 존재한다면 @Primary 어노테이션으로 우선순위를 설정할 수 있다.  
  @Qulifer 어노테이션으로 Bean이름을 통해서 주입 받을 수 있고, 해당 타입의 빈을 모두 List를 통해서 주입 받을 수 있다.  
  
---

### Web Server vs Web Application Server의 차이를 아시나요?

  Web Server는 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠인 HTML, image file, css 등을 제공하는 서버를 말합니다. Web Server의 예로는 Apach Server, Nginx 등이 있습니다.  
  Web Application Server는 DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server를 말합니다. HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어입니다.  
  WAS는 Web Container 혹은 Servlet Container라고도 불리며 대표적인 예로는 Tomcat, Jetty 등이 있습니다.  
  Web Server와 WAS를 분리하는 이유는 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 분리합니다.

---
### Spring container 종류
  1. BeanFactory : DI의 기본사항을 제공하는 컨테이너, 빈을 생성하고 분배하는 작업을 한다.
  2. ApplicationContext : bean 팩토리와 유사하지만 더 많은 기능을 제공한다. 미리 빈을 생성해놓아 빈이 필요할때 즉시 사용할 수 있도록 보장한다.
---

### 컨테이너(container)
* 프레임워크 안에서 인스턴스들의 생명 주기를 관리하며, 생성된 인스턴스에 추가적인 기능을 제공한다.
* 내가 작업한 코드 처리과정이 컨테이너에서 실행된다.
* 스프링 컨테이너는 스프링 프레임워크 핵심적인 위치에 존재하며 DI를 통한 애플리케이션을 구성하는 컴포넌트를 관리한다.

---
### VO와 DTO, BO, DAO란? 
* DAO(Data Access Object): DB에 접근하여 실제 데이터를 조회 또는 조작하는 클래스, Repository 또는 Mapper에 해당함
* BO(Business Object): 여러 DAO를 활용해 비지니스 로직을 처리하는 클래스, Service에 해당함
* DTO(Data Transfer Object): 데이터를 주고 받기 위해 사용하는 클래스
* VO(Value Object): 실제 데이터만을 저장하는 클래스

---
### 디자인 패턴(Design Pattern)

1. **생성 패턴**
  * **팩토리 패턴** : 객체를 생성하기 위한 디자인 패턴
  * **추상 팩토리 패턴** : 객체를 생성하는 팩토리를 생성하기 위한 디자인 패턴
  * **빌더 패턴** : 상황에 따라 동적인 인자를 필요로 하는 객체를 생성하기 위한 디자인 패턴
  * **싱글톤 패턴** : 객체를 1개만 생성하여 항상 참조 가능하도록 고인된 디자인 패턴


2. **구조 패턴**
  * **어댑터 패턴** : 호환성이 맞지 않는 두 클래스를 연결하여 사용하기 위한 디자인 패턴
  * **프록시 패턴** : 어떤 객체에 접근하기 위해 대리인을 사용하는 디자인 패턴
  * **데코레이션 패턴**
  * **퍼사드 패턴** : 어떤 복합적인 기능에 대해 간략화된 인터페이스를 제공하는 디자인 패턴


3. **행위 패턴**
  * **전략 패턴** : 상황에 따라 다른 전략을 사용하기 위한 디자인 패턴
  * **옵저버 패턴** : 값을 관찰하여 빠르게 반영하기 위한 디자인 패턴
  * **커맨드 패턴** : 실행될 기능을 캡슐화하여 재사용성이 높은 클래스를 설계하기 위한 디자인 패턴

  
---
### Servlet(서블릿)
      서블릿이란 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술이다.
      Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후 결과를 반환한다.
---

### 디스패처 서블릿(Dispatcher Servlet)
    디스패처 서블릿이란 톰캣과 같은 서블릿 컨테이너를 통해 들어오는 모든 요청을 제일 앞에서 받는 컨트롤러 이다.
    디스패처 서블릿은 공통된 작업을 처리한 후에 , 적절한 세부 컨트롤러로 작업을 위임해준다. 그리고 각각의 세부 컨트롤러는 처리할 부분을 처리하고
    반환할 view를 Dispatcher Servlet에 넘기게 된다.

<img width="656" alt="스크린샷 2022-01-01 오후 11 16 30" src="https://user-images.githubusercontent.com/73993220/147852595-07c51014-fd59-4a3e-b308-08eaa086d5f7.png">

---
### Spring filter와 Intercepter 차이
필터는 웹 컨테이너에서 관리하고 요청/응답이 조작 가능하다.
필터는 보안관련 공통 작업할때 사용하고, 모든 요청에 대한 로깅 또는 감사를 한다.

인터셉터는 스프링 컨테이너에서 관리하고 요청/응답 조작이 불가능하다.
인터셉터는 인증/인가 등과 같은 공통작업을 할때 사용되고, Controller로 넘겨주는 정보의 가공을 담당한다.
또, API 호출에 대한 로깅 또는 감사를 한다

### IOC Container
IOC container는 객체의 생성과 관계 설정, 사용, 제거 등의 전체 라이프 사이클을 관리해주는 작업을 하는 컨테이너를 Ioc컨테이너라 한다.  
Ioc Container의 대표적인 명세는 BeanFactory인데 요즘은 이를 상속하는 Application Context를 사용한다.  
왜냐하면 Application Context는 BeanFactory의 기능 뿐만 아니라, 메세지 다국화, 이벤트 발행기능, 리소스 로딩 기능등의 여러 기능을 제공한다.  
    
spring Ioc Container의 Bean 등록방법에는 Xml설정 파일을 통해 Bean 등록, @Annotation을 통해 Bean 등록하는 방법이 있다.  
하지만 Annotation기반의 Bean 등록시에는 Component Scan을 필요로 한다. 직접 등록해줄수도 있지만 SpringBoot에서는 CommponentScan을 자동으로 설정해준다.
* @Configuration : 스프링 설정으로 사용하겠다는 의미
* @EnableAutoConfiguration : 지정해둔 설정 값들을 자동으로 설정하는 기능을 킨다는 의미
* @ComponentScan, @Component, @Configuration 붙은 클래스를 Bean으로 등록  
---

### CDN(content Delivery Network)
    CDN은 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공하기 위해 고안된 기술이다.
    만약 우리나라에 있는 사람이 미국에 있는 서버로 부터 이미지나 파일 등을 다운받으려고 하면 시간이 오래걸린다.
    따라서 느린 응답속도와 다운로드 시간을 극복하기 위해 서버를 분산시켜 캐싱해두고, 빠르게 다운 받을 수 있게 한다.
    CDN은 콘텐츠에 대한 요청이 발생하면 사용자와 가장 가까운 위치에 존재하는 서버로 매핑시켜, 요청된 파일의 캐싱된 버전으로 요청 처리한다.
    서버가 파일을 찾는 데 실패하는 경우 CDN플랫폼의 다른 서버에서 콘텐츠를 찾은 다음 엔드 유저에게 응답을 전송한다.


### Spring WebFlux
    Spring WebFlux란 Blocking+동기 방식으로 동작하는 Spring MVC의 한계점을 극복하기 위해 Spring5에 처음 등장하게 되었습니다. 
    기존의 Spring MVC에서는 HTTP 요청들을 큐에 넣어두고, 멀티쓰레드를 기반으로 동작하고 있습니다. 
    하지만 이러한 방식은 응답성이 상대적으로 떨어지기 때문에 비동기적으로 요청을 처리하기 위한 방법이 필요하게 되었고, 
    리액티브 프로그래밍을 통해 비동기 데이터 스트림으로 Non-Blocking 애플리케이션을 개발하기 위한 Spring WebFlux 프레임워크가 등장하게 되었습니다.

### Spring AOP의 작동 원리(JDK 다이나믹 프록시)
1. 다이내믹 프록시 객체의 생성 요청
2. 포인트컷을 통해 부가 기능 대상 여부 확인
3. 어드바이스로 부가 기능 적용
4. 실제 기능 처리

Spring AOP는 프록시를 이용하였으며 자바의 기본 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 필요로 하지 않습니다. 하지만 이러한 프록시 방법은 반드시 Spring 컨테이너가 필요하며 부가기능의 처리가 어려운 단점이 있어서, 바이트를 조작하는 AOP가 등장하게 되었습니다.

---
### AspectJ AOP의 작동 원리(CGLib 기반 바이트 조작 프록시)
Spring AOP 외에 또 다른 강력한 AOP 프레임워크 중 하나인 AspectJ는 프록시를 이용하지 않았습니다.  
대신 AspectJ는 CGlib이라는 바이트 조작 라이브러리를 사용하여 타깃 오브젝트의 바이트를 고쳐서 부가기능을 직접 넣어주는 방법(바이트 조작)을 사용합니다.  
그래서 우리가 만든 코드에서는 부가 기능이 분리되어 있지만 바이트 코드에서는 핵심 기능과 부가 기능이 섞여있는 구조입니다.   
AspectJ가 프록시를 사용하지 않고 CGLib을 이용한 복잡한 바이트 조작 방법을 사용하는 이유는 크게 2가지가 있습니다.
* 바이트 코드를 조작하면 Spring과 같은 컨테이너의 도움이 필요 없기 때문이다.
* 프록시 방식보다 훨씬 강력하고 유연한 AOP를 제공할 수 있다.


